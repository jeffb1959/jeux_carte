<!-- Version v7.5.1 ‚Äî 2025-11-14 ‚Äî Zone TEST : Redondance √©limin√©e / CSS externe -->
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Dame de Pique ‚Äî v7.5.1 (zone test)</title>
  <link rel="stylesheet" href="dame_de_pique.css">

</head>
<body>
  <main class="wrap">
    <header class="card" aria-labelledby="title">
      <h1 id="title">Dame de Pique</h1>
      <h2 id="passRule" class="subhead">R√®gle : ‚Äî</h2>
      <div class="muted" id="meta" style="margin-top:4px">
        Code soir√©e: <strong id="code">‚Äî</strong> ‚Ä¢ Tour <strong id="round">1</strong> ‚Ä¢ Brasseur: <strong id="dealerName">‚Äî</strong>
      </div>
      <div class="row" style="margin-top:8px">
        <span class="muted" id="ruleHint"></span>
        <div class="pill" aria-label="Statut de la connexion">
          <span class="pill-dot"></span>
          <span id="connStatus">Hors ligne</span>
        </div>
      </div>
    </header>

    <section class="card" aria-label="Joueurs et totaux">
      <div class="section-title">Joueurs</div>
      <div id="playersList" class="players"></div>
    </section>

    <section class="card" aria-label="Scores de la ronde en cours">
      <div class="scores-header">
        <div class="section-title">Scores</div>
      </div>
      <p class="scores-meta">
        Somme des scores attendue : <strong>25 points</strong>.
      </p>
      <button id="btnOpenScore" class="btn" type="button" aria-haspopup="dialog" aria-controls="modalScore">
        Inscrire mon pointage
      </button>
      <div id="roundStatus" class="status" aria-live="polite">0/0 soumis</div>
      <div id="roundError" class="error" aria-live="assertive"></div>
    </section>

    <section class="card" aria-label="Contr√¥les de la partie">
      <div class="section-title">Contr√¥les</div>
      <p class="muted" id="hostInfo">Vous n‚Äô√™tes pas l‚Äôh√¥te de la partie.</p>
      <button id="btnRefresh" class="btn btn-secondary" type="button">
        Rafra√Æchir l‚Äô√©cran
      </button>
    </section>

    <section class="card" aria-label="Diagnostics">
      <details>
        <summary>Diagnostics (debug)</summary>
        <div class="diag">
          <div id="diagOutput"></div>
        </div>
      </details>
    </section>

    <section class="card" aria-label="Fin de partie">
      <button id="btnFinish" class="btn-pale-danger hold2s" type="button">
        <span>Fin de partie (maintenir)</span>
        <div class="fill"></div>
      </button>
      <div id="hostOnlyHint" class="hostOnlyText">Visible uniquement pour l‚Äôh√¥te de la partie.</div>
      <div id="endMessage" class="endMsg"></div>
    </section>

    <div class="footer">v7.5.1 ‚Äî zone test (m√™me UI, CSS externe)</div>
  </main>

  <!-- Config Firebase -->
  <script>
    window.firebaseConfig = {
      apiKey: "AIzaSyDLSnoOCdHXl-5sKaJ55hhFbv-quS156kg",
      authDomain: "soireecartev2.firebaseapp.com",
      projectId: "soireecartev2",
      storageBucket: "soireecartev2.firebasestorage.app",
      messagingSenderId: "784781686361",
      appId: "1:784781686361:web:7b01398afbe1dab3652be2"
    };
  </script>

  <!-- Init / √©tat global -->
  <script type="module">
    import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import { getFirestore } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    const state = {
      soireeCode: "",
      gameId: "",
      players: [],
      dealerIndex: 0,
      round: 1,
      totals: {},
      roundScores: {},
      lastRoundPer: null,
      myIndex: -1,
      deviceId: null,
      authUid: null,
      _db: null,
      currentInputs: {},
      scoresRaw: null,
      gameOver: false,
      winnerId: null
    };

    function readUrl(){
      const params = new URLSearchParams(location.search);
      state.soireeCode = params.get("code") || "";
      state.gameId     = params.get("gid") || "";
      const codeSpan=document.getElementById("code");
      if(codeSpan) codeSpan.textContent = state.soireeCode || "‚Äî";
      const roundLabel=document.getElementById("round");
      if(roundLabel) roundLabel.textContent = String(state.round);
    }

    function diagnosticsPush(lines){
      const el = document.getElementById("diagOutput");
      if(!el) return;
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");
      const prefix = `[${hh}:${mm}:${ss}] `;
      const text = (Array.isArray(lines)? lines:[lines]).map(l=>prefix+l).join("\n");
      el.textContent = text + "\n" + el.textContent;
    }

    function resolveDeviceIdAtBoot() {
      try {
        const qs = new URLSearchParams(location.search);
        const fromUrl = qs.get("did");
        if (fromUrl) {
          state.deviceId = fromUrl;
          try { localStorage.setItem("deviceId", fromUrl); } catch(_) {}
          return;
        }

        const stored =
          localStorage.getItem("deviceId") ||
          localStorage.getItem("dame_de_pique_deviceId");

        if (stored) {
          state.deviceId = stored;
          return;
        }

        console.warn("[boot] Aucun deviceId trouv√© dans l'URL ni le localStorage.");
      } catch (e) {
        console.warn("[boot] Erreur lors de la r√©solution du deviceId :", e);
      }
    }

    function bootUi(){
      const passRuleEl = document.getElementById("passRule");
      if (passRuleEl) passRuleEl.textContent = "R√®gle : ‚Äî";
      const cs = document.getElementById("connStatus");
      if(cs) cs.textContent = "Connexion en cours‚Ä¶";
    }

    async function ensureAuth(){
      if(!window.firebaseConfig){
        console.warn("[ensureAuth] firebaseConfig manquant ‚Äî lecture d√©sactiv√©e.");
        return null;
      }
      const app = getApps().length ? getApps()[0] : initializeApp(window.firebaseConfig);
      const auth = getAuth(app);
      const db   = getFirestore(app);
      state._db  = db;
      try{
        await signInAnonymously(auth);
      }catch(e){
        if(!auth.currentUser) throw e;
      }
      return new Promise((resolve)=>
        onAuthStateChanged(auth, (user)=>{
          state.authUid = user?.uid || null;
          resolve({ app, auth, db, uid: state.authUid });
        })
      );
    }

    function getDb(){ return state._db; }

    async function boot(){
      readUrl();
      resolveDeviceIdAtBoot();
      bootUi();
    }

    window.ModInit = { state, boot, ensureAuth, getDb, diagnosticsPush };
  </script>

  <!-- Soir√©e -->
  <script type="module">
    import { doc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    let unsubscribeSoiree=null;
    function listenSoiree(db, code, onData){
      if(!db||!code){ console.warn("[listenSoiree] db/code manquant"); return ()=>{}; }
      if(unsubscribeSoiree){ try{unsubscribeSoiree();}catch(_){} unsubscribeSoiree=null; }
      const ref = doc(db,"soirees",code);
      unsubscribeSoiree = onSnapshot(
        ref,
        (snap)=>{
          if(!snap.exists()){ onData?.(null); return; }
          onData?.(snap.data()||{});
        },
        (err)=> console.error("[listenSoiree] erreur snapshot:",err)
      );
      return ()=>{ if(unsubscribeSoiree) unsubscribeSoiree(); };
    }

    window.ModSoiree = { listenSoiree };
  </script>

  <!-- Scores (√©coute + √©criture inputs.<deviceId>) -->
  <script type="module">
    import { doc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    let unsubscribeScores=null;

    function extractTotals(data){
      if (data && typeof data.totals === 'object' && !Array.isArray(data.totals)) {
        const t = data.totals;
        const keys = Object.keys(t);
        const looksLikePN = keys.length && keys.every(k => /^p\d+$/i.test(k));
        if (looksLikePN) {
          const out = {};
          for (const k of keys) {
            const m = /^p(\d+)$/i.exec(k);
            const idx = m ? parseInt(m[1], 10) : null;
            if (idx != null) out[String(idx)] = Number(t[k]) || 0;
          }
          return out;
        }
        const looksLikeIndex = keys.every(k=>/^\d+$/.test(k));
        if (looksLikeIndex) {
          const out={};
          for(const k of keys){
            const idx = parseInt(k,10);
            out[String(idx)] = Number(t[k]) || 0;
          }
          return out;
        }
        return t;
      }

      if (data && data.standings && typeof data.standings.totals === 'object') {
        return data.standings.totals;
      }

      if (data && data.standings && typeof data.standings === 'object' && !Array.isArray(data.standings)) {
        return data.standings;
      }

      if (data && data.lastRound && Array.isArray(data.lastRound.perRound)) {
        const o = {}; data.lastRound.perRound.forEach((v,i)=> o[String(i)] = Number(v)||0);
        return o;
      }

      return null;
    }

    function extractRound(data){
      if (data && Number.isInteger(data.round)) return data.round;
      if (data && data.roundState && Number.isInteger(data.roundState.round)) return data.roundState.round;
      if (data && data.lastRound && Number.isInteger(data.lastRound.round)) return data.lastRound.round;
      return null;
    }

    function listenScores(db, gid, onData){
      if(!db||!gid){ console.warn("[listenScores] db/gid manquant"); return ()=>{}; }
      if(unsubscribeScores){ try{unsubscribeScores();}catch(_){} unsubscribeScores=null; }
      const ref = doc(db, "scores_dame_de_pique", gid);
      unsubscribeScores = onSnapshot(
        ref,
        (snap)=>{
          if(!snap.exists()){ onData?.(null); return; }
          const raw = snap.data()||{};
          const inputs = (raw.inputs && typeof raw.inputs === "object" && !Array.isArray(raw.inputs))
            ? raw.inputs
            : {};
          try{
            if (window.ModInit && window.ModInit.state) {
              window.ModInit.state.currentInputs = inputs;
              window.ModInit.state.scoresRaw = raw;
              window.ModInit.state.gameOver = !!raw.gameOver;
              window.ModInit.state.winnerId = raw.winnerId || null;
            }
          }catch(_){}

          const totals = extractTotals(raw);
          const round  = extractRound(raw);
          const extra  = { lastRoundPer: (raw.lastRound && Array.isArray(raw.lastRound.perRound)) ? raw.lastRound.perRound : null };
          onData?.({ totals, round, extra, raw });
        },
        (err)=> console.error("[listenScores] erreur snapshot:", err)
      );
      return ()=>{ if(unsubscribeScores) unsubscribeScores(); };
    }

    async function submitScoreForCurrentDevice(score){
      const mod = window.ModInit || {};
      const state = mod.state || {};
      const getDb = mod.getDb;
      if (!getDb) {
        console.warn("[submitScore] getDb absent");
        return;
      }
      const db = getDb();
      if (!db) {
        console.warn("[submitScore] DB indisponible");
        return;
      }
      if (!state.gameId) {
        console.warn("[submitScore] gameId manquant");
        return;
      }
      if (!state.deviceId) {
        console.warn("[submitScore] deviceId manquant");
        return;
      }

      const s = Number(score);
      if (!Number.isFinite(s)) {
        console.warn("[submitScore] score invalide:", score);
        return;
      }

      const ref = doc(db, "scores_dame_de_pique", state.gameId);
      try{
        await updateDoc(ref, { ["inputs."+state.deviceId]: s });
      }catch(e){
        console.error("[submitScore] erreur updateDoc:", e);
      }
    }

    window.ModScores = { listenScores, submitScoreForCurrentDevice };
  </script>

  <!-- R√®gles de ronde -->
  <script type="module">
    import { doc, updateDoc } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    function computePassRule(round){
      const rules=['√Ä droite','√Ä gauche','√Ä centre','Garde tes cartes'];
      return rules[(Math.max(1,round)-1)%4];
    }

    function computeRoundSummary(players, inputs){
      const ordered = (players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0));
      const perRound = [];
      let sum = 0;
      let filledCount = 0;

      ordered.forEach((p, idx) => {
        const did = p && p.deviceId;
        let v = null;
        if (did && inputs && Object.prototype.hasOwnProperty.call(inputs, did)) {
          v = Number(inputs[did]);
          if (!Number.isFinite(v)) v = 0;
          filledCount++;
        }
        perRound[idx] = v;
        if (v != null) sum += v;
      });

      const expected = ordered.length;
      const isComplete = expected > 0 && filledCount === expected;
      const isValid25 = isComplete && sum === 25;

      let grandIndex = -1;
      let isGrand = false;
      if (isComplete && isValid25) {
        const nonZero = [];
        perRound.forEach((v, idx) => {
          if (v && v !== 0) nonZero.push({ idx, v });
        });
        if (nonZero.length === 1 && nonZero[0].v === 25) {
          isGrand = true;
          grandIndex = nonZero[0].idx;
        }
      }

      return {
        perRound,
        sum,
        isComplete,
        isValid25,
        isGrandChelem: isGrand,
        grandChelemIndex: grandIndex
      };
    }

    async function applyRoundScore(summary){
      const mod = window.ModInit || {};
      const state = mod.state || {};
      const getDb = mod.getDb;
      if (!getDb) {
        console.warn('[applyRoundScore] getDb absent');
        return;
      }
      const db = getDb();
      if (!db) {
        console.warn('[applyRoundScore] DB indisponible');
        return;
      }
      if (!state.gameId) {
        console.warn('[applyRoundScore] gameId manquant');
        return;
      }

      if (state.scoresRaw && state.scoresRaw.gameOver === true) {
        console.warn('[applyRoundScore] Partie d√©j√† termin√©e (gameOver=true). Aucune nouvelle ronde appliqu√©e.');
        return;
      }

      if (!summary || !summary.isComplete || !summary.isValid25) {
        return;
      }

      const playersOrdered = (state.players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0));
      const n = playersOrdered.length;
      if (!n) return;

      const baseTotals = [];
      for (let i=0;i<n;i++){
        const key = String(i);
        const total = Number.isFinite(state.totals?.[key]) ? state.totals[key] : 0;
        baseTotals.push(total);
      }

      let roundVals = summary.perRound.slice();
      let gameOver = false;

      if (summary.isGrandChelem && summary.grandChelemIndex >= 0) {
        roundVals = roundVals.map((v, idx) => (idx === summary.grandChelemIndex ? 0 : 25));
      }

      const newTotals = baseTotals.map((t, idx) => {
        const add = Number.isFinite(roundVals[idx]) ? roundVals[idx] : 0;
        return t + add;
      });

      const limit = 100;
      let winnerIdx = -1;
      for (let i=0;i<n;i++){
        if (newTotals[i] >= limit) {
          gameOver = true;
        }
      }

      if (gameOver) {
        let minVal = Infinity;
        let minIdx = -1;
        for (let i=0;i<n;i++){
          if (newTotals[i] < minVal) {
            minVal = newTotals[i];
            minIdx = i;
          }
        }
        winnerIdx = minIdx;
      }

      const ref = doc(db, "scores_dame_de_pique", state.gameId);

      const totalsMap={};
      newTotals.forEach((v, idx)=> totalsMap[String(idx)] = v);

      let winnerId = null;
      if (winnerIdx >= 0 && playersOrdered[winnerIdx]) {
        winnerId = playersOrdered[winnerIdx].deviceId || null;
      }

      const roundNumber = Number.isInteger(state.round) ? state.round : 1;
      const payload = {
        lastRound: {
          appliedGrandChelem: !!summary.isGrandChelem,
          controleIndex: -1,
          perRound: roundVals,
          round: roundNumber,
          sum: roundVals.reduce((a,b)=> a + (Number(b)||0), 0),
          values: roundVals
        },
        totals: totalsMap,
        round: roundNumber + 1,
        gameOver: gameOver,
        winnerId: gameOver ? (winnerId || null) : null,
        roundError: "",
        inputs: {}
      };

      try{
        await updateDoc(ref, payload);
        console.debug('[applyRoundScore] Ronde appliqu√©e et totaux mis √† jour.');
      }catch(e){
        console.error('[applyRoundScore] erreur updateDoc:', e);
      }
    }

    function checkGameOver(){ return false; }

    window.ModRounds = { computePassRule, computeRoundSummary, applyRoundScore, checkGameOver };
  </script>

  <!-- Rendu UI -->
  <script type="module">
    const $=(id)=>document.getElementById(id);

    function renderPlayers(){
      const { state } = window.ModInit;
      const { computePassRule } = window.ModRounds;
      const host=$('playersList'); if(!host) return; host.innerHTML='';
      (state.players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0)).forEach((p,idx)=>{
        const row=document.createElement('div'); row.className='player-row';
        const left=document.createElement('div');
        const name=document.createElement('div'); name.className='player-name'; name.textContent=p?.name||`Joueur ${idx+1}`;
        if(idx===state.dealerIndex){
          const badge=document.createElement('span'); badge.className='badge'; badge.textContent='Brasseur';
          name.appendChild(badge);
        }
        left.appendChild(name);
        const right=document.createElement('div'); right.className='player-total';
        const key = (p.id!=null)? String(p.id): String(idx);
        const total = Number.isFinite(state.totals?.[key]) ? state.totals[key] : 0;
        right.textContent=`Total: ${total}`;
        row.appendChild(left); row.appendChild(right); host.appendChild(row);
      });
      const pass=computePassRule(window.ModInit.state.round);
      const dealerName=(window.ModInit.state.players?.[window.ModInit.state.dealerIndex]?.name)||'‚Äî';
      $('dealerName').textContent=dealerName; $('round').textContent=String(window.ModInit.state.round);
      const meta=document.getElementById('meta');
      if(meta){
        meta.innerHTML=`Code soir√©e: <strong id="code">${window.ModInit.state.soireeCode||'‚Äî'}</strong> ‚Ä¢ Tour <strong id="round">${window.ModInit.state.round}</strong> ‚Ä¢ Brasseur: <strong id="dealerName">${dealerName}</strong>`;
      }
      const passEl=document.getElementById('passRule'); if(passEl) passEl.textContent=`R√®gle : ${pass}`;
    }

    function renderTotals(){
      const { state } = window.ModInit;
      const host = document.getElementById('totals');

      if (host) {
        host.innerHTML = '';

        (state.players||[]).forEach((p,idx)=>{
          const line=document.createElement('div'); line.className='line';
          const n=document.createElement('div'); n.textContent=p?.name||`Joueur ${idx+1}`;
          const v=document.createElement('div');
          const key = (p.id!=null)? String(p.id): String(idx);
          const total = Number.isFinite(state.totals?.[key]) ? state.totals[key] : 0;
          v.textContent=String(total);
          line.appendChild(n); line.appendChild(v); host.appendChild(line);
        });
      }

      const inputs = state.currentInputs || {};
      const submitted = Object.keys(inputs).length;
      const expected = (state.players||[]).length;
      const rs = document.getElementById('roundStatus');
      if (rs) rs.textContent = `${submitted}/${expected} soumis`;

      const re = document.getElementById('roundError');
      if (re) {
        const { computeRoundSummary, applyRoundScore } = window.ModRounds;

        if (state.gameOver) {
          if (rs) rs.textContent = "Partie termin√©e.";

          const btn = document.getElementById('btnOpenScore');
          if (btn) {
            btn.disabled = true;
            btn.textContent = "Partie termin√©e";
          }

          let winnerName = "‚Äî";
          let winnerTotal = null;

          const ordered = (state.players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0));

          if (state.winnerId) {
            const idx = ordered.findIndex(p => p && p.deviceId === state.winnerId);
            if (idx >= 0) {
              winnerName = ordered[idx].name || `Joueur ${idx+1}`;
              const key = String(idx);
              winnerTotal = Number(state.totals?.[key] || 0);
            }
          }

          if (winnerName === "‚Äî") {
            let minTotal = Infinity;
            let minIdx = -1;
            Object.keys(state.totals || {}).forEach(k=>{
              const v = Number(state.totals[k] || 0);
              if (v < minTotal) {
                minTotal = v;
                minIdx = parseInt(k,10);
              }
            });
            if (minIdx >= 0 && ordered[minIdx]) {
              winnerName = ordered[minIdx].name || `Joueur ${minIdx+1}`;
              winnerTotal = minTotal;
            }
          }

          if (winnerTotal != null) {
            re.textContent = `Partie termin√©e. Gagnant : ${winnerName} avec ${winnerTotal} points.`;
          } else {
            re.textContent = `Partie termin√©e. Gagnant : ${winnerName}.`;
          }

          return;
        }

        const summary = computeRoundSummary(state.players, inputs);

        if (!summary.isComplete) {
          re.textContent = "";
        } else if (!summary.isValid25) {
          re.textContent = `Erreur: la somme des scores est ${summary.sum}, elle doit √™tre exactement 25.`;
        } else if (summary.isGrandChelem) {
          const ordered = (state.players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0));
          const winnerPlayer = ordered[summary.grandChelemIndex];
          const nm = winnerPlayer?.name || `Joueur ${summary.grandChelemIndex+1}`;
          re.textContent = `Grand chelem d√©tect√© pour ${nm} (25). Les totaux seront ajust√©s (0 pour ${nm}, 25 pour les autres).`;
          applyRoundScore(summary);
        } else {
          re.textContent = `OK : tous les scores sont saisis et la somme est 25. Les totaux sont mis √† jour pour la prochaine ronde.`;
          applyRoundScore(summary);
        }
      }
    }

    function renderAll(){
      renderPlayers();
      renderTotals();
    }

    window.ModUI = { renderPlayers, renderTotals, renderAll };
  </script>

  <!-- Actions / √©v√©nements -->
  <script type="module">
    const $=(id)=>document.getElementById(id);
    const { state, boot, ensureAuth, getDb, diagnosticsPush } = window.ModInit;
    const { listenSoiree } = window.ModSoiree;
    const { listenScores, submitScoreForCurrentDevice } = window.ModScores;
    const { computeRoundSummary, applyRoundScore } = window.ModRounds;
    const { renderPlayers, renderTotals, renderAll } = window.ModUI;

    function openModal(){
      const bd=$('modalScoreBackdrop');
      if(bd){ bd.style.display='flex'; }
      const input=$('scoreInput');
      if(input){
        input.value='';
        input.focus();
      }
      const err=$('modalError'); if(err) err.textContent='';
    }

    function closeModal(){
      const bd=$('modalScoreBackdrop');
      if(bd){ bd.style.display='none'; }
    }

    function setupModal(){
      const btnOpen=$('btnOpenScore');
      if(btnOpen){
        btnOpen.addEventListener('click',()=>{
          if(state.gameOver){
            const re=$('roundError');
            if(re) re.textContent="La partie est termin√©e.";
            return;
          }
          openModal();
        });
      }

      const btnCancel=$('btnCancelScore');
      if(btnCancel){
        btnCancel.addEventListener('click',(ev)=>{
          ev.preventDefault();
          closeModal();
        });
      }

      const form=$('scoreForm');
      if(form){
        form.addEventListener('submit', async (ev)=>{
          ev.preventDefault();
          const input=$('scoreInput');
          const modalErr=$('modalError');
          const v = input ? Number(input.value) : NaN;
          if(!Number.isFinite(v) || v<0 || v>25){
            if(modalErr) modalErr.textContent="Entrez un nombre entre 0 et 25.";
            return;
          }
          if(modalErr) modalErr.textContent="";
          try{
            await submitScoreForCurrentDevice(v);
          }catch(e){
            console.error('[scoreForm] erreur submitScore:', e);
            if(modalErr) modalErr.textContent="Erreur lors de l‚Äôenregistrement du score. R√©essayez.";
            return;
          }
          closeModal();
        });
      }
    }

    function setupRefresh(){
      const btn=$('btnRefresh');
      if(!btn) return;
      btn.addEventListener('click',()=>{
        const dv=$('diagOutput');
        if(dv){
          const now=new Date();
          const hh=String(now.getHours()).padStart(2,'0');
          const mm=String(now.getMinutes()).padStart(2,'0');
          const ss=String(now.getSeconds()).padStart(2,'0');
          dv.textContent=`[${hh}:${mm}:${ss}] Rafra√Æchissement manuel demand√©.\n`+dv.textContent;
        }
      });
    }

    function setupFinishButton(){
      const btnFinish = $('btnFinish');
      const finishSection = btnFinish?.closest('.card');
      const fill = btnFinish?.querySelector('.fill');

      function updateHostVisibility(){
        const isHost = !!(state.deviceId && state.players?.[state.dealerIndex]?.deviceId === state.deviceId);
        if(finishSection){
          finishSection.style.display = isHost ? 'block' : 'none';
        }
      }

      state._updateHostVisibility = updateHostVisibility;
      updateHostVisibility();

      if(!btnFinish || !fill) return;

      let timer=null;
      let progress=0;
      const totalHold=2000;
      const step=50;

      function resetFill(){
        progress=0;
        fill.style.width='0%';
      }

      btnFinish.addEventListener('mousedown',(ev)=>{
        ev.preventDefault();
        if(state.gameOver){
          diagnosticsPush('Fin de partie d√©j√† appliqu√©e.');
          return;
        }
        resetFill();
        timer = setInterval(()=>{
          progress += step;
          const pct = Math.min(100, (progress/totalHold)*100);
          fill.style.width = pct+'%';
          if(progress>=totalHold){
            clearInterval(timer);
            timer=null;
            fill.style.width='100%';
            forceGameOver();
          }
        }, step);
      });

      btnFinish.addEventListener('mouseup',()=>{
        if(timer){
          clearInterval(timer);
          timer=null;
        }
        resetFill();
      });
      btnFinish.addEventListener('mouseleave',()=>{
        if(timer){
          clearInterval(timer);
          timer=null;
        }
        resetFill();
      });

      async function forceGameOver(){
        const db = getDb && getDb();
        if(!db || !state.gameId){
          diagnosticsPush('Impossible de terminer la partie : DB ou gameId manquant.');
          return;
        }
        const firestore = await import("https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js");
        const { doc, updateDoc } = firestore;
        const ref = doc(db,"scores_dame_de_pique",state.gameId);

        let winnerId = null;
        if (state.totals && Object.keys(state.totals).length>0) {
          let minVal = Infinity;
          let minKey = null;
          for(const k of Object.keys(state.totals)){
            const v = Number(state.totals[k]||0);
            if(v < minVal){
              minVal = v;
              minKey = k;
            }
          }
          const ordered = (state.players||[]).slice().sort((a,b)=>(a?.order??0)-(b?.order??0));
          const idx = minKey!=null ? parseInt(minKey,10): -1;
          if(idx>=0 && ordered[idx]){
            winnerId = ordered[idx].deviceId || null;
          }
        }

        try{
          await updateDoc(ref,{
            gameOver:true,
            winnerId:winnerId || null
          });
          state.gameOver=true;
          state.winnerId=winnerId||null;
          diagnosticsPush('Fin de partie forc√©e par l‚Äôh√¥te.');
          renderAll();
        }catch(e){
          console.error('[forceGameOver] erreur updateDoc:',e);
          diagnosticsPush('Erreur lors de la fin de partie. Voir console.');
        }
      }
    }

    document.addEventListener('DOMContentLoaded', async ()=>{
      await boot();
      renderAll();
      setupModal();
      setupRefresh();
      setupFinishButton();

      const notes=[];
      if(!window.firebaseConfig){
        notes.push('‚ÑπÔ∏è firebaseConfig manquant ‚Üí lecture d√©sactiv√©e.');
        diagnosticsPush(notes);
        return;
      }
      notes.push('‚è≥ Auth anonyme‚Ä¶');
      const ctx = await ensureAuth();
      const db=ctx?.db, uid=ctx?.uid;
      if(!db){
        notes.push('‚ùå Auth/DB indisponible.');
        diagnosticsPush(notes);
        return;
      }
      notes.push('‚úÖ Auth OK. UID: '+(uid||'(anonyme)'));

      const cs=document.getElementById('connStatus');
      if(cs) cs.textContent='Connect√©';

      if(!state.soireeCode){
        notes.push('‚ÑπÔ∏è ?code=XXXX manquant ‚Üí pas d\'√©coute soirees.');
        diagnosticsPush(notes);
        return;
      }
      notes.push('üëÇ √âcoute soirees/'+state.soireeCode+' ‚Ä¶');
      listenSoiree(db, state.soireeCode, (data)=>{
        if(!data){
          notes.push('‚ö†Ô∏è Doc soirees inexistant');
          diagnosticsPush(notes);
          return;
        }
        state.players = Array.isArray(data.players)? data.players : (data.players?.list||[]);
        state.dealerIndex = Number.isInteger(data.leaderIndex)? data.leaderIndex : (data.dealerIndex ?? 0);
        if(Number.isInteger(data.round)) state.round = data.round;
        let dlName = data.leaderName;
        if(!dlName && Array.isArray(state.players) && state.players[state.dealerIndex]){
          dlName = state.players[state.dealerIndex]?.name || '‚Äî';
        }
        document.getElementById('dealerName').textContent = dlName || '‚Äî';
        if (typeof state._updateHostVisibility === 'function') {
          state._updateHostVisibility();
        }
        renderAll();
        diagnosticsPush([
          ...notes,
          'üì¶ Maj soirees: players='+(state.players?.length||0)+', dealerIndex='+state.dealerIndex+', round='+state.round
        ]);
      });

      if(state.gameId){
        notes.push('üëÇ √âcoute scores_dame_de_pique/'+state.gameId+' ‚Ä¶');
        listenScores(db, state.gameId, ({ totals, round, extra, raw })=>{
          const inputs = window.ModInit.state.currentInputs || {};
          const inputsCount = Object.keys(inputs).length;

          if(!totals && !round){
            diagnosticsPush([
              ...notes,
              `‚ÑπÔ∏è Doc scores sans champs totals/round (inputs=${inputsCount}).`
            ]);
            renderAll();
            return;
          }

          if(totals) state.totals = totals;
          if(Number.isInteger(round)) state.round = round;
          if(extra && Array.isArray(extra.lastRoundPer)) state.lastRoundPer = extra.lastRoundPer;

          renderAll();
          diagnosticsPush([
            ...notes,
            'üì¶ Maj scores: totals='+(Object.keys(state.totals||{}).length)+', round='+state.round+`, inputs=${inputsCount}, gameOver=${state.gameOver}`
          ]);
        });
      } else {
        notes.push('‚ÑπÔ∏è ?gid=... manquant ‚Üí pas d\'√©coute scores.');
        diagnosticsPush(notes);
      }
    });
  </script>
</body>
</html>
